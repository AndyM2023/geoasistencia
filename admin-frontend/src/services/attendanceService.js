import api from './api';

// ‚úÖ CONFIGURACI√ìN: Umbral de confianza para verificaci√≥n facial
const CONFIDENCE_THRESHOLD = 0.90; // 90% - Solo entradas con 90% o superior de confianza

export const attendanceService = {
    // Variable para almacenar el token de autenticaci√≥n
    authToken: null,

    // M√©todo para establecer el token
    setAuthToken(token) {
        this.authToken = token;
        console.log('üîë Token de autenticaci√≥n establecido');
    },

    // M√©todo para obtener headers con autenticaci√≥n
    getAuthHeaders() {
        if (this.authToken) {
            return {
                'Authorization': `Bearer ${this.authToken}`,
                'Content-Type': 'application/json'
            };
        }
        return {
            'Content-Type': 'application/json'
        };
    },

    async verifyFaceAndMarkAttendance(employeeId, photoBase64, areaId, latitude, longitude) {
        try {
            console.log('üîç Verificando rostro para asistencia...');
            
            // Primero verificar el rostro
            const faceVerification = await this.verifyFace(employeeId, photoBase64);
            
            if (!faceVerification.verified) {
                throw new Error(`Rostro no reconocido: ${faceVerification.message}`);
            }
            
            // ‚úÖ VALIDACI√ìN DE UMBRAL DE CONFIANZA: Solo permitir 90% o superior
            if (faceVerification.confidence < CONFIDENCE_THRESHOLD) {
                throw new Error(`Confianza insuficiente: ${(faceVerification.confidence * 100).toFixed(1)}%. Se requiere m√≠nimo ${(CONFIDENCE_THRESHOLD * 100)}% para registrar asistencia.`);
            }
            
            console.log(`‚úÖ Rostro verificado con confianza ${(faceVerification.confidence * 100).toFixed(1)}%, marcando asistencia...`);
            
            // Si el rostro es verificado y cumple el umbral, marcar asistencia
            const attendance = await this.markAttendance(employeeId, areaId, latitude, longitude, true);
            
            return {
                success: true,
                faceVerified: true,
                confidence: faceVerification.confidence,
                attendance: attendance,
                message: 'Asistencia marcada exitosamente con verificaci√≥n facial'
            };
            
        } catch (error) {
            console.error('‚ùå Error en verificaci√≥n facial y asistencia:', error);
            throw error;
        }
    },

    async verifyFace(employeeId, photoBase64) {
        try {
            const response = await api.post(`/employees/${employeeId}/verify_face/`, {
                photo: photoBase64
            }, {
                headers: this.getAuthHeaders()
            });
            
            // ‚úÖ LOGGING MEJORADO: Mostrar informaci√≥n de confianza y umbral
            const result = response.data;
            if (result.verified && result.confidence !== undefined) {
                const confidencePercent = (result.confidence * 100).toFixed(1);
                const thresholdPercent = (CONFIDENCE_THRESHOLD * 100).toFixed(0);
                console.log(`üéØ Verificaci√≥n facial: ${confidencePercent}% de confianza (Umbral requerido: ${thresholdPercent}%)`);
                
                if (result.confidence < CONFIDENCE_THRESHOLD) {
                    console.warn(`‚ö†Ô∏è ADVERTENCIA: Confianza ${confidencePercent}% est√° por debajo del umbral requerido de ${thresholdPercent}%`);
                }
            }
            
            return result;
        } catch (error) {
            console.error('Error verificando rostro:', error);
            throw error;
        }
    },

    async markAttendance(employeeId, areaId, latitude, longitude, faceVerified = false) {
        try {
            console.log('üìù MARK_ATTENDANCE - Enviando datos:');
            console.log(`   - Employee ID: ${employeeId}`);
            console.log(`   - Area ID: ${areaId}`);
            console.log(`   - Latitude: ${latitude}`);
            console.log(`   - Longitude: ${longitude}`);
            console.log(`   - Face verified: ${faceVerified}`);
            
            const requestData = {
                employee_id: employeeId,
                area_id: areaId,
                latitude: latitude,
                longitude: longitude,
                face_verified: faceVerified
            };
            
            console.log('üì§ Request data completo:', requestData);
            
            const url = `/attendance/mark_attendance/`;
            console.log('üåê URL completa:', url);
            console.log('üîë Headers de autenticaci√≥n:', this.getAuthHeaders());
            
            const response = await api.post(url, requestData, {
                headers: this.getAuthHeaders()
            });
            
            console.log('‚úÖ Respuesta del backend:', response.data);
            return response.data;
        } catch (error) {
            console.error('‚ùå Error marcando asistencia:', error);
            if (error.response) {
                console.error('üì° Respuesta del servidor:', error.response.data);
                console.error('üìä Estado HTTP:', error.response.status);
                console.error('üåê URL que fall√≥:', error.config?.url);
            }
            throw error;
        }
    },

    async getEmployeeByCredentials(username, password) {
        try {
            // Hacer login para obtener el usuario usando el endpoint de empleados
            const loginResponse = await api.post(`/auth/employee_login/`, {
                username: username,
                password: password
            });
            
            const user = loginResponse.data.user;
            const token = loginResponse.data.token;
            
            console.log('üîç Respuesta del login de empleado:', loginResponse.data);
            console.log('üë§ Usuario obtenido:', user);
            console.log('üîë Token obtenido:', token ? 'S√ç' : 'NO');
            
            // Establecer el token de autenticaci√≥n para futuras peticiones
            if (token) {
                this.setAuthToken(token);
                // Tambi√©n guardar en localStorage para que el interceptor de api.js lo use
                localStorage.setItem('token', token);
                localStorage.setItem('refreshToken', loginResponse.data.refresh);
            }
            
            // Obtener la informaci√≥n del empleado usando el token
            const employeeResponse = await api.get(`/employees/`);
            const responseData = employeeResponse.data;
            
            console.log('üîç Respuesta del endpoint /employees/:', employeeResponse);
            console.log('üìä responseData:', responseData);
            
            // Manejar respuesta paginada del backend
            let employees;
            if (responseData.results && Array.isArray(responseData.results)) {
                // Respuesta paginada: usar el campo 'results'
                employees = responseData.results;
                console.log('‚úÖ Usando respuesta paginada, empleados encontrados:', employees.length);
            } else if (Array.isArray(responseData)) {
                // Respuesta directa como array
                employees = responseData;
                console.log('‚úÖ Respuesta directa como array, empleados encontrados:', employees.length);
            } else {
                console.error('‚ùå Formato de respuesta no reconocido:', responseData);
                throw new Error('Formato de respuesta inv√°lido del servidor');
            }
            
            // Buscar el empleado que corresponda al usuario
            const employee = employees.find(emp => emp.user.id === user.id);
            
            if (!employee) {
                throw new Error('Usuario no es un empleado registrado');
            }
            
            console.log('‚úÖ Empleado encontrado:', employee);
            
            return {
                user: user,
                employee_id: employee.id,
                area_id: employee.area
            };
        } catch (error) {
            console.error('Error en login:', error);
            throw error;
        }
    },

    // M√©todo para obtener todas las asistencias
    async getAll(filters = {}) {
        try {
            console.log('üìä Obteniendo todas las asistencias con filtros:', filters);
            console.log('üîë Token disponible:', this.authToken ? 'S√ç' : 'NO');
            console.log('üîë Token en localStorage:', localStorage.getItem('token') ? 'S√ç' : 'NO');
            
            let url = '/attendance/';
            const params = new URLSearchParams();
            
            // Aplicar filtros si est√°n presentes
            if (filters.employee) {
                params.append('employee_id', filters.employee);
            }
            if (filters.area) {
                params.append('area_id', filters.area);
            }
            if (filters.status && filters.status !== 'all') {
                params.append('status', filters.status);
            }
            if (filters.dateFrom) {
                // Asegurar que la fecha est√© en formato YYYY-MM-DD usando zona horaria local
                let dateFrom = filters.dateFrom;
                if (dateFrom instanceof Date) {
                    // Usar zona horaria local para evitar problemas de UTC
                    const year = dateFrom.getFullYear();
                    const month = String(dateFrom.getMonth() + 1).padStart(2, '0');
                    const day = String(dateFrom.getDate()).padStart(2, '0');
                    dateFrom = `${year}-${month}-${day}`;
                } else if (typeof dateFrom === 'string' && dateFrom.includes('T')) {
                    dateFrom = dateFrom.split('T')[0];
                }
                params.append('date_from', dateFrom);
                console.log('üìÖ Fecha desde enviada al backend:', dateFrom);
            }
            if (filters.dateTo) {
                // Asegurar que la fecha est√© en formato YYYY-MM-DD usando zona horaria local
                let dateTo = filters.dateTo;
                if (dateTo instanceof Date) {
                    // Usar zona horaria local para evitar problemas de UTC
                    const year = dateTo.getFullYear();
                    const month = String(dateTo.getMonth() + 1).padStart(2, '0');
                    const day = String(dateTo.getDate()).padStart(2, '0');
                    dateTo = `${year}-${month}-${day}`;
                } else if (typeof dateTo === 'string' && dateTo.includes('T')) {
                    dateTo = dateTo.split('T')[0];
                }
                params.append('date_to', dateTo);
                console.log('üìÖ Fecha hasta enviada al backend:', dateTo);
            }
            
            if (params.toString()) {
                url += '?' + params.toString();
            }
            
            console.log('üåê URL de consulta:', url);
            console.log('üîë Headers de autenticaci√≥n:', this.getAuthHeaders());
            
            // Verificar que el token est√© disponible antes de hacer la petici√≥n
            const token = localStorage.getItem('token');
            if (!token) {
                throw new Error('No hay token de autenticaci√≥n disponible');
            }
            
            console.log('üîë Token que se enviar√°:', token.substring(0, 30) + '...');
            
            // Verificar que la URL base est√© configurada correctamente
            console.log('üåê URL base de la API:', api.defaults.baseURL);
            console.log('üåê URL completa que se enviar√°:', api.defaults.baseURL + url);
            
            // Comparar con la petici√≥n exitosa
            console.log('üîç COMPARACI√ìN CON PETICI√ìN EXITOSA:');
            console.log('   - URL del proxy (exitosa): /app/attendance/');
            console.log('   - URL del servicio: ' + api.defaults.baseURL + url);
            console.log('   - ¬øSon iguales?', '/app/attendance/' === (api.defaults.baseURL + url));
            
            const response = await api.get(url, {
                headers: this.getAuthHeaders()
            });
            
            console.log('‚úÖ Respuesta del backend:', response.data);
            console.log('üìä Estado HTTP:', response.status);
            console.log('üìä Headers de respuesta:', response.headers);
            
            // Manejar respuesta paginada del backend
            if (response.data.results && Array.isArray(response.data.results)) {
                console.log('‚úÖ Respuesta paginada, usando results');
                return response.data.results;
            } else if (Array.isArray(response.data)) {
                console.log('‚úÖ Respuesta directa como array');
                return response.data;
            } else {
                console.error('‚ùå Formato de respuesta no reconocido:', response.data);
                return [];
            }
        } catch (error) {
            console.error('‚ùå Error obteniendo asistencias:', error);
            console.error('üì° Detalles del error:', {
                message: error.message,
                status: error.response?.status,
                statusText: error.response?.statusText,
                data: error.response?.data,
                config: error.config,
                url: error.config?.url,
                method: error.config?.method
            });
            throw error;
        }
    },

    // M√©todo para obtener asistencias por rango de fechas
    async getByDateRange(startDate, endDate, additionalFilters = {}) {
        try {
            console.log('üìÖ Obteniendo asistencias por rango de fechas:', { startDate, endDate, additionalFilters });
            
            const filters = {
                dateFrom: startDate,
                dateTo: endDate,
                ...additionalFilters
            };
            
            return await this.getAll(filters);
        } catch (error) {
            console.error('‚ùå Error obteniendo asistencias por rango de fechas:', error);
            throw error;
        }
    },

    // ===== M√âTODOS PARA EMPLEADOS =====
    
    // Obtener informaci√≥n del empleado autenticado
    async getEmployeeInfo() {
        try {
            console.log('üë§ Obteniendo informaci√≥n del empleado...');
            const response = await api.get('/dashboard/employee_info/');
            console.log('‚úÖ Informaci√≥n del empleado obtenida:', response.data);
            return response.data;
        } catch (error) {
            console.error('‚ùå Error obteniendo informaci√≥n del empleado:', error);
            throw error;
        }
    },

    // Obtener estad√≠sticas del empleado autenticado
    async getEmployeeStats() {
        try {
            console.log('üìä Obteniendo estad√≠sticas del empleado...');
            const response = await api.get('/dashboard/employee_stats/');
            console.log('‚úÖ Estad√≠sticas del empleado obtenidas:', response.data);
            return response.data;
        } catch (error) {
            console.error('‚ùå Error obteniendo estad√≠sticas del empleado:', error);
            throw error;
        }
    },

    // Obtener historial de asistencias del empleado autenticado
    async getEmployeeAttendances() {
        try {
            console.log('üìã Obteniendo historial de asistencias del empleado...');
            const response = await api.get('/dashboard/employee_attendances/');
            console.log('‚úÖ Historial de asistencias obtenido:', response.data);
            return response.data.attendances || [];
        } catch (error) {
            console.error('‚ùå Error obteniendo historial de asistencias:', error);
            throw error;
        }
    }
};
