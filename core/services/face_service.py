import os
import sys
import json
import base64
import subprocess
import time
import numpy as np
import cv2
from io import BytesIO
from PIL import Image
from django.conf import settings
from django.utils import timezone
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
from ..models import FaceProfile

# Agregar el directorio de reconocimiento facial al path
FACE_RECOGNITION_DIR = os.path.join(settings.BASE_DIR, 'face_recognition')
if FACE_RECOGNITION_DIR not in sys.path:
    sys.path.insert(0, FACE_RECOGNITION_DIR)

print(f"üîç DEBUG: IMPORT PATHS DURANTE CARGA DEL M√ìDULO")
print(f"   - FACE_RECOGNITION_DIR: {FACE_RECOGNITION_DIR}")
print(f"   - sys.path contiene FACE_RECOGNITION_DIR: {FACE_RECOGNITION_DIR in sys.path}")
print(f"   - sys.path[0]: {sys.path[0] if sys.path else 'Empty'}")
print(f"   - Current working directory: {os.getcwd()}")

try:
    from advanced_face_system import FacialRecognition
    FACIAL_RECOGNITION_AVAILABLE = True
    print(f"‚úÖ Sistema facial importado correctamente desde: {FACE_RECOGNITION_DIR}")
    print(f"   - FacialRecognition class: {FacialRecognition}")
    print(f"   - FacialRecognition type: {type(FacialRecognition)}")
except ImportError as e:
    print(f"‚ö†Ô∏è Sistema facial no disponible: {e}")
    print(f"   Path actual: {sys.path}")
    print(f"   Archivo buscado: {os.path.join(FACE_RECOGNITION_DIR, 'advanced_face_system.py')}")
    FacialRecognition = None
    FACIAL_RECOGNITION_AVAILABLE = False

class FaceRecognitionService:
    """Servicio para integrar el sistema de reconocimiento facial"""
    
    def __init__(self):
        print(f"üîç DEBUG: INICIALIZANDO FaceRecognitionService")
        print(f"   - Current working directory: {os.getcwd()}")
        print(f"   - BASE_DIR: {settings.BASE_DIR}")
        
        self.face_system_path = os.path.join(settings.BASE_DIR, 'face_recognition')
        self.faces_dir = os.path.join(self.face_system_path, 'faces')
        
        print(f"   - face_system_path: {self.face_system_path}")
        print(f"   - faces_dir: {self.faces_dir}")
        print(f"   - face_system_path exists: {os.path.exists(self.face_system_path)}")
        print(f"   - faces_dir exists: {os.path.exists(self.faces_dir)}")
        
        # Inicializar sistema facial si est√° disponible
        print(f"   - FACIAL_RECOGNITION_AVAILABLE: {FACIAL_RECOGNITION_AVAILABLE}")
        print(f"   - FacialRecognition class: {FacialRecognition}")
        
        if FACIAL_RECOGNITION_AVAILABLE:
            try:
                print(f"   - Intentando crear FacialRecognition...")
                self.facial_system = FacialRecognition(
                    base_dir=self.face_system_path,
                    database_name="faces"
                )
                print(f"   - FacialRecognition creado: {self.facial_system}")
                print(f"   - facial_system type: {type(self.facial_system)}")
                print(f"   - facial_system is None: {self.facial_system is None}")
                
                if self.facial_system:
                    print(f"   - facial_system methods: {[m for m in dir(self.facial_system) if not m.startswith('_')]}")
                    print(f"   - facial_system base_dir: {getattr(self.facial_system, 'base_dir', 'N/A')}")
                    print(f"   - facial_system face_dir: {getattr(self.facial_system, 'face_dir', 'N/A')}")
                else:
                    print(f"   ‚ùå FacialRecognition se cre√≥ pero es None")
                    
            except Exception as e:
                print(f"   ‚ùå Error inicializando sistema facial: {e}")
                import traceback
                traceback.print_exc()
                self.facial_system = None
        else:
            print(f"   ‚ùå FACIAL_RECOGNITION_AVAILABLE es False")
            self.facial_system = None
        
        print(f"   - FINAL: facial_system = {self.facial_system}")
        print(f"   - FINAL: facial_system is None = {self.facial_system is None}")
        print(f"   - FINAL: bool(facial_system) = {bool(self.facial_system)}")
    
    def register_employee_face(self, employee, photos_data):
        """Alias para mantener compatibilidad - redirige al m√©todo principal"""
        return self.register_or_update_employee_face(employee, photos_data)
    
    def register_or_update_employee_face(self, employee, photos_data):
        """
        Registra o actualiza m√∫ltiples fotos de un empleado usando el sistema facial real
        ‚úÖ OPTIMIZADO PARA VELOCIDAD: 15 fotos + procesamiento en lotes
        """
        print(f"üîç FACE_SERVICE.register_or_update_employee_face INICIADO")
        print(f"   - Employee: {employee.full_name}")
        print(f"   - Photos data type: {type(photos_data)}")
        print(f"   - Photos data length: {len(photos_data) if photos_data else 0}")
        print(f"   - ‚ö†Ô∏è PROCESAMIENTO √öNICO: Este m√©todo se ejecuta SOLO UNA VEZ")
        
        # üîç DEBUG: Verificar estado del servicio facial ANTES de procesar
        print(f"\nüîç DEBUG: VERIFICANDO ESTADO DEL SERVICIO FACIAL EN FACE_SERVICE")
        print(f"   - self: {self}")
        print(f"   - self type: {type(self)}")
        print(f"   - self.facial_system: {self.facial_system}")
        print(f"   - self.facial_system type: {type(self.facial_system)}")
        print(f"   - self.facial_system is None: {self.facial_system is None}")
        print(f"   - self.facial_system bool evaluation: {bool(self.facial_system)}")
        print(f"   - self.face_system_path: {self.face_system_path}")
        print(f"   - self.faces_dir: {self.faces_dir}")
        
        if self.facial_system:
            print(f"   - facial_system methods: {[m for m in dir(self.facial_system) if not m.startswith('_')]}")
            print(f"   - facial_system base_dir: {getattr(self.facial_system, 'base_dir', 'N/A')}")
            print(f"   - facial_system face_dir: {getattr(self.facial_system, 'face_dir', 'N/A')}")
        else:
            print("   ‚ùå facial_system es None o False")
            
        # üîç DEBUG: Verificar si hay alg√∫n problema con la inicializaci√≥n
        print(f"\nüîç DEBUG: VERIFICANDO INICIALIZACI√ìN DEL SERVICIO")
        print(f"   - FACE_RECOGNITION_AVAILABLE (module level): {FACIAL_RECOGNITION_AVAILABLE}")
        print(f"   - FacialRecognition class: {FacialRecognition}")
        
        try:
            # Verificar si ya existe un perfil facial
            is_update = False
            try:
                existing_profile = employee.face_profile
                is_update = True
                print(f"üîÑ ACTUALIZANDO REGISTRO FACIAL PARA EMPLEADO: {employee.full_name}")
                print(f"üì∏ Fotos anteriores: {existing_profile.photos_count}")
            except FaceProfile.DoesNotExist:
                print(f"üÜï NUEVO REGISTRO FACIAL PARA EMPLEADO: {employee.full_name}")
            
            print(f"üì∏ Fotos nuevas recibidas: {len(photos_data)}")
            
            if not self.facial_system:
                print("‚ùå Sistema facial no disponible")
                print("üîç DEBUG: facial_system es None/False, verificando por qu√©...")
                print(f"   - self.facial_system: {self.facial_system}")
                print(f"   - bool(self.facial_system): {bool(self.facial_system)}")
                print(f"   - self.facial_system is None: {self.facial_system is None}")
                return {
                    'success': False,
                    'message': 'Sistema de reconocimiento facial no disponible'
                }
            
            # Crear ID √∫nico para el empleado
            employee_id = f"{employee.employee_id or employee.id}"
            
            # ‚úÖ NUEVA L√ìGICA: SOLO USAR ID (m√°s robusto)
            # Ya no usamos el nombre del empleado para evitar problemas de sincronizaci√≥n
            print(f"üÜî ID del empleado: {employee_id}")
            print(f"üìù Nombre del empleado: {employee.user.first_name} {employee.user.last_name}")
            print(f"üéØ NUEVA ESTRATEGIA: Carpeta solo con ID para m√°xima robustez")
            
            # Crear carpeta para el empleado (SOLO ID - m√°s robusto)
            employee_folder = os.path.join(self.faces_dir, f"{employee_id}")
            
            # Si es actualizaci√≥n, limpiar carpeta anterior
            if is_update and os.path.exists(employee_folder):
                print(f"üßπ Limpiando carpeta anterior: {employee_folder}")
                import shutil
                shutil.rmtree(employee_folder)
                print(f"‚úÖ Carpeta anterior eliminada")
            
            os.makedirs(employee_folder, exist_ok=True)
            
            print(f"üìÅ Carpeta creada: {employee_folder}")
            print(f"üìÅ Carpeta existe: {os.path.exists(employee_folder)}")
            
            # ‚úÖ PROCESAMIENTO ULTRA-OPTIMIZADO: Decodificaci√≥n en lote + procesamiento paralelo
            saved_photos = 0
            rejected_photos = 0
            total_photos = len(photos_data)
            
            # ‚úÖ OPTIMIZACI√ìN ESPECIAL: Detectar si son pocas fotos para modo ultra-r√°pido
            if total_photos <= 20:
                print(f"üöÄ MODO ULTRA-R√ÅPIDO - {total_photos} fotos con Facenet-128")
                print(f"‚ö° VELOCIDAD M√ÅXIMA: Procesamiento directo sin lotes")
                print(f"‚è±Ô∏è Tiempo estimado: {total_photos * 0.2:.1f} segundos (MODO ULTRA-R√ÅPIDO)")
                ultra_fast_mode = True
            else:
                print(f"üöÄ PROCESAMIENTO ULTRA-OPTIMIZADO - {total_photos} fotos con Facenet-128")
                print(f"‚ö° VELOCIDAD M√ÅXIMA: Decodificaci√≥n en lote + procesamiento paralelo")
                print(f"‚è±Ô∏è Tiempo estimado: {total_photos * 0.3:.1f} segundos (ULTRA-OPTIMIZADO)")
                ultra_fast_mode = False
            
            if ultra_fast_mode:
                # ‚úÖ MODO ULTRA-R√ÅPIDO: Para pocas fotos (‚â§20)
                print(f"‚ö° MODO ULTRA-R√ÅPIDO: Procesando {total_photos} fotos directamente...")
                
                # Procesar cada foto directamente sin lotes
                for i, photo_data in enumerate(photos_data):
                    try:
                        print(f"üì∏ Procesando foto {i+1}/{total_photos}...")
                        
                        # Decodificar imagen
                        face_image = self._decode_base64_image(photo_data)
                        if face_image is None:
                            print(f"   ‚ùå Foto {i+1} rechazada: Sin rostro v√°lido")
                            rejected_photos += 1
                            continue
                        
                        # Extraer caracter√≠sticas
                        features = self.facial_system.extract_face_features(face_image)
                        if features is None:
                            print(f"   ‚ùå Foto {i+1} sin caracter√≠sticas v√°lidas")
                            rejected_photos += 1
                            continue
                        
                        # Guardar directamente
                        timestamp = int(time.time() * 1000000) + i
                        photo_path = os.path.join(employee_folder, f"face_{timestamp}.jpg")
                        
                        if cv2.imwrite(photo_path, face_image, [cv2.IMWRITE_JPEG_QUALITY, 70]):
                            embedding_path = photo_path.replace('.jpg', '.npy')
                            np.save(embedding_path, features)
                            
                            if os.path.exists(embedding_path):
                                saved_photos += 1
                                print(f"   ‚úÖ Foto {i+1} guardada exitosamente")
                            else:
                                rejected_photos += 1
                                if os.path.exists(photo_path):
                                    os.remove(photo_path)
                        else:
                            rejected_photos += 1
                            print(f"   ‚ùå Error guardando foto {i+1}")
                            
                    except Exception as e:
                        rejected_photos += 1
                        print(f"   ‚ùå Error procesando foto {i+1}: {e}")
                        continue
                        
            else:
                # ‚úÖ MODO NORMAL: Para muchas fotos (>20)
                print(f"üîÑ Decodificando {total_photos} im√°genes en lote ultra-optimizado...")
                
                # Usar el nuevo m√©todo de decodificaci√≥n en lote
                face_images = self._batch_decode_base64_images(photos_data)
                
                # Filtrar im√°genes v√°lidas
                valid_face_images = []
                valid_photos = []
                
                for i, face_image in enumerate(face_images):
                    if face_image is not None:
                        valid_face_images.append(face_image)
                        valid_photos.append(i)
                        print(f"   ‚úÖ Foto {i+1} decodificada: {face_image.shape}")
                    else:
                        print(f"   ‚ùå Foto {i+1} rechazada: Sin rostro v√°lido")
                        rejected_photos += 1
                
                print(f"üì∏ Im√°genes v√°lidas para procesamiento: {len(valid_face_images)}")
                
                # ‚úÖ OPTIMIZACI√ìN 2: Procesamiento en lote usando el sistema facial optimizado
                if valid_face_images:
                    print(f"üß† Procesando {len(valid_face_images)} rostros en lote...")
                    
                    # Usar el nuevo m√©todo batch_extract_features del sistema facial
                    features_list = self.facial_system.batch_extract_features(valid_face_images)
                    
                    # ‚úÖ OPTIMIZACI√ìN 3: Guardar en paralelo usando ThreadPoolExecutor
                    print(f"üíæ Guardando {len(valid_face_images)} rostros en paralelo...")
                    
                    def save_face_data(args):
                        i, face_image, features, valid_photo_idx = args
                        try:
                            if features is not None:
                                timestamp = int(time.time() * 1000000) + valid_photo_idx
                                photo_path = os.path.join(employee_folder, f"face_{timestamp}.jpg")
                                
                                # ‚úÖ OPTIMIZACI√ìN: Compresi√≥n m√°s r√°pida (70 en lugar de 85)
                                if cv2.imwrite(photo_path, face_image, [cv2.IMWRITE_JPEG_QUALITY, 70]):
                                    embedding_path = photo_path.replace('.jpg', '.npy')
                                    np.save(embedding_path, features)
                                    
                                    if os.path.exists(embedding_path):
                                        print(f"   ‚úÖ Rostro {valid_photo_idx+1} guardado exitosamente")
                                        return True
                                    else:
                                        if os.path.exists(photo_path):
                                            os.remove(photo_path)
                                        return False
                                else:
                                    return False
                            else:
                                print(f"   ‚ùå Rostro {valid_photo_idx+1} sin caracter√≠sticas v√°lidas")
                                return False
                        except Exception as e:
                            print(f"   ‚ùå Error guardando rostro {valid_photo_idx+1}: {e}")
                            return False
                    
                    # ‚úÖ PROCESAMIENTO PARALELO: M√°ximo 3 hilos para balance velocidad/estabilidad
                    with ThreadPoolExecutor(max_workers=3) as executor:
                        save_args = [(i, face_image, features, valid_photos[i]) 
                                    for i, (face_image, features) in enumerate(zip(valid_face_images, features_list))]
                        
                        results = list(executor.map(save_face_data, save_args))
                        saved_photos = sum(results)
                        rejected_photos += (len(valid_face_images) - saved_photos)
            
            print(f"üéØ Procesamiento ultra-optimizado completado: {saved_photos}/{total_photos} fotos procesadas")
            print(f"‚úÖ Servidor Django sigue funcionando - Terminal NO se cierra")
            
            print(f"\nüìä RESUMEN DEL PROCESAMIENTO:")
            print(f"   üì∏ Fotos procesadas: {saved_photos}")
            print(f"   üìÅ Archivos en carpeta: {len(os.listdir(employee_folder)) if os.path.exists(employee_folder) else 0}")
            
            if saved_photos == 0:
                print("‚ùå No se pudo procesar ninguna foto")
                return {
                    'success': False,
                    'message': 'No se pudo procesar ninguna foto'
                }
            
            # Crear o actualizar perfil facial
            face_profile, created = FaceProfile.objects.get_or_create(
                employee=employee,
                defaults={
                    'face_embeddings_path': employee_folder,
                    'photos_count': saved_photos,
                    'is_trained': True,
                    'last_training': timezone.localtime()
                }
            )
            
            if not created:
                face_profile.photos_count = saved_photos
                face_profile.is_trained = True
                face_profile.last_training = timezone.localtime()
                face_profile.save()
            
            print(f"‚úÖ FACE_SERVICE: Registro facial completado exitosamente")
            print(f"   - Fotos guardadas: {saved_photos}")
            print(f"   - Empleado: {employee.full_name}")
            print(f"   - Employee ID: {employee_id}")
            
            result = {
                'success': True,
                'message': f'Registradas {saved_photos} fotos para {employee.full_name}',
                'photos_count': saved_photos,
                'employee_id': employee_id
            }
            
            print(f"üîç FACE_SERVICE: Retornando resultado: {result}")
            print(f"‚úÖ PROCESAMIENTO COMPLETADO: {saved_photos} fotos procesadas UNA SOLA VEZ")
            return result
            
        except Exception as e:
            return {
                'success': False,
                'message': f'Error registrando rostro: {str(e)}'
            }
    
    def verify_face(self, employee, photo_data):
        """
        Verifica si una foto coincide con el rostro registrado del empleado
        ‚úÖ IMPLEMENTACI√ìN ULTRA-OPTIMIZADA PARA M√ÅXIMA VELOCIDAD
        
        Args:
            employee: Instancia del modelo Employee
            photo_data: Imagen en base64
            
        Returns:
            dict: Resultado de la verificaci√≥n
        """
        try:
            face_profile = employee.face_profile
            if not face_profile.is_trained:
                return {
                    'success': False,
                    'verified': False,
                    'message': 'Empleado no tiene rostro registrado'
                }
            
            # Verificaci√≥n facial real usando el sistema de reconocimiento
            if not self.facial_system:
                return {
                    'success': False,
                    'verified': False,
                    'message': 'Sistema de reconocimiento facial no disponible'
                }
            
            try:
                print(f"‚ö° VERIFICACI√ìN ULTRA-R√ÅPIDA para {employee.full_name}")
                print(f"üéØ Objetivo: < 2 segundos de respuesta")
                
                # ‚úÖ OPTIMIZACI√ìN 1: Decodificaci√≥n r√°pida CON extracci√≥n de rostro
                captured_image = self._decode_base64_image_fast(photo_data)
                if captured_image is None:
                    return {
                        'success': False,
                        'verified': False,
                        'message': 'Error procesando imagen capturada'
                    }
                
                # ‚úÖ OPTIMIZACI√ìN 2: Extraer rostro de manera r√°pida
                print(f"üîç Extracci√≥n r√°pida de rostro para verificaci√≥n...")
                face_image = self._extract_face_region_fast(captured_image)
                
                # ‚úÖ OPTIMIZACI√ìN 3: Verificaci√≥n directa con Facenet-512
                print(f"üîç Verificaci√≥n directa con Facenet-512...")
                
                # Generar embedding de la imagen del rostro extra√≠do
                captured_embedding = self.facial_system.extract_face_features(face_image)
                if captured_embedding is None:
                    return {
                        'success': False,
                        'verified': False,
                        'message': 'No se pudieron extraer caracter√≠sticas del rostro'
                    }
                
                # ‚úÖ CONVERTIR A NUMPY ARRAY para poder usar .min() y .max()
                captured_embedding = np.array(captured_embedding)
                
                # ‚úÖ OPTIMIZACI√ìN 3: Comparar solo con embeddings del empleado (m√°s r√°pido)
                employee_id = str(employee.employee_id or employee.id)
                employee_folder = os.path.join(self.faces_dir, f"{employee_id}")
                
                if not os.path.exists(employee_folder):
                    return {
                        'success': False,
                        'verified': False,
                        'message': 'Carpeta del empleado no encontrada'
                    }
                
                print(f"üîç DEBUG - Carpeta del empleado: {employee_folder}")
                print(f"üîç DEBUG - Embedding capturado: {len(captured_embedding)}D, rango: [{captured_embedding.min():.3f}, {captured_embedding.max():.3f}]")
                
                # Buscar embeddings del empleado
                best_similarity = 0.0
                embeddings_found = 0
                
                for file_name in os.listdir(employee_folder):
                    if file_name.endswith('.npy'):
                        embedding_path = os.path.join(employee_folder, file_name)
                        try:
                            stored_embedding = np.load(embedding_path)
                            
                            # ‚úÖ CALCULAR SIMILITUD USANDO F√ìRMULA CORRECTA (como en el sistema anterior)
                            # Usar similitud coseno que es m√°s precisa para embeddings
                            dot_product = np.dot(captured_embedding, stored_embedding)
                            norm1 = np.linalg.norm(captured_embedding)
                            norm2 = np.linalg.norm(stored_embedding)
                            
                            if norm1 > 0 and norm2 > 0:
                                # F√≥rmula de similitud coseno normalizada a [0,1]
                                similarity = (dot_product / (norm1 * norm2) + 1) / 2
                            else:
                                similarity = 0.0
                            
                            # ‚úÖ DEBUG: Mostrar detalles de cada comparaci√≥n
                            print(f"   üîç Embedding {embeddings_found+1}: rango [{stored_embedding.min():.3f}, {stored_embedding.max():.3f}], similitud: {similarity:.3f}")
                            
                            if similarity > best_similarity:
                                best_similarity = similarity
                            
                            embeddings_found += 1
                            
                            # ‚úÖ OPTIMIZACI√ìN 4: Parar si ya encontramos una similitud alta
                            if similarity >= 0.95:  # 95% de confianza
                                break
                                
                        except Exception as e:
                            continue
                
                if embeddings_found == 0:
                    return {
                        'success': False,
                        'verified': False,
                        'message': 'No se encontraron embeddings del empleado'
                    }
                
                # ‚úÖ OPTIMIZACI√ìN 5: Umbral configurable para velocidad vs precisi√≥n
                verified = best_similarity >= face_profile.confidence_threshold
                
                print(f"üéØ Resultado ultra-r√°pido:")
                print(f"   Similitud m√°xima: {best_similarity:.3f}")
                print(f"   Umbral configurado: {face_profile.confidence_threshold}")
                print(f"   Embeddings comparados: {embeddings_found}")
                print(f"   Verificaci√≥n: {'‚úÖ EXITOSA' if verified else '‚ùå FALLIDA'}")
                
                message = f'Rostro verificado correctamente (Similitud: {best_similarity:.3f})' if verified else f'Rostro no reconocido (Similitud: {best_similarity:.3f})'
                
                return {
                    'success': True,
                    'verified': verified,
                    'confidence': best_similarity,
                    'threshold': face_profile.confidence_threshold,
                    'message': message
                }
                
            except Exception as e:
                print(f"‚ùå Error en verificaci√≥n ultra-r√°pida: {e}")
                return {
                    'success': False,
                    'verified': False,
                    'message': f'Error en verificaci√≥n: {str(e)}'
                }
            
        except FaceProfile.DoesNotExist:
            return {
                'success': False,
                'verified': False,
                'message': 'Empleado no tiene perfil facial'
            }
        except Exception as e:
            return {
                'success': False,
                'verified': False,
                'message': f'Error en verificaci√≥n: {str(e)}'
            }
    
    def get_employee_face_status(self, employee):
        """
        Obtiene el estado del perfil facial de un empleado de forma SIMPLE
        ‚úÖ VERIFICA: Base de datos + Archivos f√≠sicos b√°sicos
        
        Args:
            employee: Instancia del modelo Employee
            
        Returns:
            dict: Estado simple del perfil facial
        """
        try:
            face_profile = employee.face_profile
            
            # Verificar si existe carpeta f√≠sica
            employee_id = str(employee.employee_id or employee.id)
            employee_folder = os.path.join(self.faces_dir, f"{employee_id}")
            folder_exists = os.path.exists(employee_folder)
            
            # ‚úÖ VERIFICACI√ìN SIMPLE: Solo contar archivos b√°sicos
            physical_photos_count = 0
            physical_embeddings_count = 0
            
            if folder_exists:
                try:
                    files = os.listdir(employee_folder)
                    
                    # Contar fotos (.jpg) y embeddings (.npy) f√≠sicos
                    for file in files:
                        if file.endswith('.jpg'):
                            physical_photos_count += 1
                        elif file.endswith('.npy'):
                            physical_embeddings_count += 1
                            
                except Exception as e:
                    print(f"‚ö†Ô∏è Error contando archivos f√≠sicos: {e}")
                    physical_photos_count = 0
                    physical_embeddings_count = 0
            
            # ‚úÖ L√ìGICA SIMPLE: Solo verificar si hay archivos f√≠sicos
            has_physical_files = physical_photos_count > 0 and physical_embeddings_count > 0
            is_actually_trained = face_profile.is_trained and has_physical_files
            
            return {
                'has_profile': True,
                'is_trained': is_actually_trained,  # Solo True si hay archivos f√≠sicos
                'photos_count': face_profile.photos_count,
                'physical_photos_count': physical_photos_count,  # Fotos reales en disco
                'physical_embeddings_count': physical_embeddings_count,  # Embeddings reales en disco
                'last_training': face_profile.last_training,
                'confidence_threshold': face_profile.confidence_threshold,
                'folder_exists': folder_exists,
                'has_physical_files': has_physical_files
            }
            
        except FaceProfile.DoesNotExist:
            return {
                'has_profile': False,
                'is_trained': False,
                'photos_count': 0,
                'physical_photos_count': 0,
                'physical_embeddings_count': 0,
                'last_training': None,
                'confidence_threshold': 0.90,
                'folder_exists': False,
                'has_physical_files': False
            }
    
    def _extract_face_region(self, image):
        """
        Extrae y recorta autom√°ticamente la regi√≥n del rostro
        ‚úÖ IMPLEMENTACI√ìN PERMISIVA - Procesa incluso si no detecta rostros claramente
        
        Args:
            image: Imagen OpenCV (numpy array)
            
        Returns:
            numpy.ndarray: Imagen recortada del rostro o la imagen completa si no se detecta
        """
        try:
            print("      ‚úÇÔ∏è Verificaci√≥n PERMISIVA de rostro...")
            
            if not self.facial_system:
                print("      ‚ö†Ô∏è Sistema facial NO disponible - Usando imagen completa")
                return image  # ‚úÖ FALLBACK: Usar imagen completa
            
            try:
                # Detectar rostros en la imagen
                faces_detected = self.facial_system.detect_faces(image)
                
                if faces_detected and len(faces_detected) > 0:
                    # Tomar el primer rostro detectado
                    face = faces_detected[0]
                    
                    # Extraer coordenadas del rostro (corregido para coincidir con detect_faces)
                    x, y, w, h = face['x'], face['y'], face['width'], face['height']
                    
                    # Verificar que el rostro tenga un tama√±o m√≠nimo v√°lido
                    min_face_size = 20  # Muy permisivo
                    if w < min_face_size or h < min_face_size:
                        print(f"      ‚ö†Ô∏è Rostro muy peque√±o: {w}x{h} - Usando imagen completa")
                        return image  # ‚úÖ FALLBACK: Usar imagen completa
                    
                    # Agregar margen alrededor del rostro (20% como en el sistema anterior)
                    margin = int(min(w, h) * 0.2)
                    x1 = max(0, x - margin)
                    y1 = max(0, y - margin)
                    x2 = min(image.shape[1], x + w + margin)
                    y2 = min(image.shape[0], y + h + margin)
                    
                    # Verificar que la regi√≥n extra√≠da sea v√°lida
                    if x2 <= x1 or y2 <= y1:
                        print(f"      ‚ö†Ô∏è Regi√≥n de rostro inv√°lida - Usando imagen completa")
                        return image  # ‚úÖ FALLBACK: Usar imagen completa
                    
                    # Recortar la regi√≥n del rostro
                    face_region = image[y1:y2, x1:x2]
                    
                    # Verificar que la regi√≥n extra√≠da no est√© vac√≠a
                    if face_region.size == 0:
                        print(f"      ‚ö†Ô∏è Regi√≥n de rostro vac√≠a - Usando imagen completa")
                        return image  # ‚úÖ FALLBACK: Usar imagen completa
                    
                    print(f"      ‚úÖ ROSTRO V√ÅLIDO extra√≠do: {face_region.shape}")
                    print(f"      üè† Regi√≥n original: {image.shape}")
                    print(f"      üìê Regi√≥n del rostro: {face_region.shape}")
                    print(f"      üìç Coordenadas: x={x1}-{x2}, y={y1}-{y2}")
                    print(f"      üéØ Tama√±o del rostro: {w}x{h}")
                    
                    return face_region
                else:
                    print("      ‚ö†Ô∏è NO SE DETECTARON ROSTROS - Usando imagen completa")
                    return image  # ‚úÖ FALLBACK: Usar imagen completa
                    
            except Exception as e:
                print(f"      ‚ö†Ô∏è Error en detecci√≥n de rostros: {e}")
                print("      ‚úÖ FALLBACK: Usando imagen completa")
                return image  # ‚úÖ FALLBACK: Usar imagen completa
                
        except Exception as e:
            print(f"      ‚ö†Ô∏è Error cr√≠tico en extracci√≥n de rostro: {e}")
            print("      ‚úÖ FALLBACK: Usando imagen completa")
            return image  # ‚úÖ FALLBACK: Usar imagen completa

    def _extract_face_region_fast(self, image):
        """
        Extracci√≥n ULTRA-R√ÅPIDA del rostro para verificaci√≥n
        ‚úÖ Versi√≥n optimizada sin logs detallados
        
        Args:
            image: Imagen OpenCV (numpy array)
            
        Returns:
            numpy.ndarray: Imagen recortada del rostro o la imagen completa
        """
        try:
            if not self.facial_system:
                return image  # ‚úÖ FALLBACK: Usar imagen completa
            
            # Detectar rostros en la imagen
            faces_detected = self.facial_system.detect_faces(image)
            
            if faces_detected and len(faces_detected) > 0:
                # Tomar el primer rostro detectado
                face = faces_detected[0]
                
                # Extraer coordenadas del rostro (corregido para coincidir con detect_faces)
                x, y, w, h = face['x'], face['y'], face['width'], face['height']
                
                # Verificar que el rostro tenga un tama√±o m√≠nimo v√°lido
                min_face_size = 20  # Muy permisivo
                if w < min_face_size or h < min_face_size:
                    return image  # ‚úÖ FALLBACK: Usar imagen completa
                
                # Agregar margen alrededor del rostro (20% como en el sistema anterior)
                margin = int(min(w, h) * 0.2)
                x1 = max(0, x - margin)
                y1 = max(0, y - margin)
                x2 = min(image.shape[1], x + w + margin)
                y2 = min(image.shape[0], y + h + margin)
                
                # Verificar que la regi√≥n extra√≠da sea v√°lida
                if x2 <= x1 or y2 <= y1:
                    return image  # ‚úÖ FALLBACK: Usar imagen completa
                
                # Recortar la regi√≥n del rostro
                face_region = image[y1:y2, x1:x2]
                
                # Verificar que la regi√≥n extra√≠da no est√© vac√≠a
                if face_region.size == 0:
                    return image  # ‚úÖ FALLBACK: Usar imagen completa
                
                return face_region
            else:
                return image  # ‚úÖ FALLBACK: Usar imagen completa
                
        except Exception as e:
            return image  # ‚úÖ FALLBACK: Usar imagen completa

    def _decode_base64_image_fast(self, base64_data):
        """
        Decodificaci√≥n ULTRA-R√ÅPIDA para verificaci√≥n de asistencia
        ‚úÖ SIN extracci√≥n de rostro para m√°xima velocidad
        
        Args:
            base64_data: String con datos de imagen en base64
            
        Returns:
            numpy.ndarray: Imagen OpenCV lista para procesar
        """
        try:
            # ‚úÖ OPTIMIZACI√ìN: Sin logs para m√°xima velocidad
            # Remover prefijo data URL si existe
            if ',' in base64_data:
                base64_data = base64_data.split(',')[1]
            
            # Decodificar base64
            image_bytes = base64.b64decode(base64_data)
            
            # Convertir a imagen PIL
            pil_image = Image.open(BytesIO(image_bytes))
            
            # Convertir a RGB si es necesario
            if pil_image.mode != 'RGB':
                pil_image = pil_image.convert('RGB')
            
            # Convertir a numpy array (OpenCV format BGR)
            opencv_image = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)
            
            return opencv_image
            
        except Exception as e:
            print(f"‚ùå Error en decodificaci√≥n r√°pida: {e}")
            return None

    def _decode_base64_image(self, base64_data):
        """
        Decodifica imagen base64 y extrae autom√°ticamente el rostro - OPTIMIZADO PARA VELOCIDAD
        ‚úÖ ULTRA-OPTIMIZADO: Menos logs, procesamiento m√°s directo
        
        Args:
            base64_data: String con datos de imagen en base64
            
        Returns:
            numpy.ndarray: Imagen del rostro recortada o None si hay error
        """
        try:
            # ‚úÖ OPTIMIZACI√ìN: Remover prefijo data URL de forma m√°s eficiente
            if ',' in base64_data:
                base64_data = base64_data.split(',', 1)[1]  # Solo dividir una vez
            
            # ‚úÖ OPTIMIZACI√ìN: Decodificaci√≥n directa sin logs excesivos
            image_bytes = base64.b64decode(base64_data)
            
            # ‚úÖ OPTIMIZACI√ìN: Usar OpenCV directamente para decodificar (m√°s r√°pido que PIL)
            try:
                # Decodificar directamente con OpenCV (m√°s r√°pido)
                nparr = np.frombuffer(image_bytes, np.uint8)
                opencv_image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
                
                if opencv_image is None:
                    # Fallback a PIL si OpenCV falla
                    pil_image = Image.open(BytesIO(image_bytes))
                    if pil_image.mode != 'RGB':
                        pil_image = pil_image.convert('RGB')
                    opencv_image = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)
                
            except Exception as e:
                # Fallback completo a PIL
                pil_image = Image.open(BytesIO(image_bytes))
                if pil_image.mode != 'RGB':
                    pil_image = pil_image.convert('RGB')
                opencv_image = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)
            
            # ‚úÖ OPTIMIZACI√ìN: Extracci√≥n de rostro m√°s eficiente
            face_image = self._extract_face_region(opencv_image)
            
            # ‚úÖ OPTIMIZACI√ìN: Retornar imagen procesada o original
            return face_image if face_image is not None else opencv_image
            
        except Exception as e:
            print(f"      ‚ùå Error decodificando imagen: {e}")
            return None
    
    def _batch_decode_base64_images(self, base64_data_list):
        """
        ‚úÖ NUEVO M√âTODO: Decodifica m√∫ltiples im√°genes base64 en lote
        OPTIMIZADO PARA VELOCIDAD - Procesa m√∫ltiples im√°genes simult√°neamente
        
        Args:
            base64_data_list: Lista de strings con datos de imagen en base64
            
        Returns:
            Lista de im√°genes OpenCV o None para im√°genes fallidas
        """
        try:
            print(f"üöÄ DECODIFICACI√ìN EN LOTE: {len(base64_data_list)} im√°genes")
            
            def decode_single_image(base64_data):
                try:
                    # ‚úÖ OPTIMIZACI√ìN: Remover prefijo data URL de forma m√°s eficiente
                    if ',' in base64_data:
                        base64_data = base64_data.split(',', 1)[1]
                    
                    # ‚úÖ OPTIMIZACI√ìN: Decodificaci√≥n directa
                    image_bytes = base64.b64decode(base64_data)
                    
                    # ‚úÖ OPTIMIZACI√ìN: Usar OpenCV directamente
                    nparr = np.frombuffer(image_bytes, np.uint8)
                    opencv_image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
                    
                    if opencv_image is None:
                        # Fallback a PIL
                        pil_image = Image.open(BytesIO(image_bytes))
                        if pil_image.mode != 'RGB':
                            pil_image = pil_image.convert('RGB')
                        opencv_image = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)
                    
                    # ‚úÖ OPTIMIZACI√ìN: Extracci√≥n de rostro
                    face_image = self._extract_face_region(opencv_image)
                    return face_image if face_image is not None else opencv_image
                    
                except Exception as e:
                    print(f"      ‚ùå Error decodificando imagen: {e}")
                    return None
            
            # ‚úÖ PROCESAMIENTO PARALELO: Decodificar en lotes de 5
            batch_size = 5
            all_images = []
            
            for i in range(0, len(base64_data_list), batch_size):
                batch = base64_data_list[i:i + batch_size]
                print(f"   üì¶ Decodificando lote {i//batch_size + 1}: {len(batch)} im√°genes")
                
                # Procesar lote en paralelo
                with ThreadPoolExecutor(max_workers=3) as executor:
                    batch_results = list(executor.map(decode_single_image, batch))
                    all_images.extend(batch_results)
            
            successful = sum(1 for img in all_images if img is not None)
            print(f"‚úÖ DECODIFICACI√ìN EN LOTE COMPLETADA: {successful}/{len(base64_data_list)} exitosas")
            
            return all_images
            
        except Exception as e:
            print(f"‚ùå Error en decodificaci√≥n en lote: {e}")
            return [None] * len(base64_data_list)
    
    def _save_base64_image(self, base64_data, file_path):
        """Guarda una imagen desde base64"""
        try:
            opencv_image = self._decode_base64_image(base64_data)
            if opencv_image is not None:
                cv2.imwrite(file_path, opencv_image)
                return True
        except Exception as e:
            print(f"Error guardando imagen: {e}")
        return False


